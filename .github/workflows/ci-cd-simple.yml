name: CI/CD Simple

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  PYTHON_VERSION: "3.11"

jobs:
  # Job 1: Testes
  tests:
    name: "Executar Testes"
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
    
    - name: Configurar Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Instalar dependências via script
      run: |
        chmod +x ./scripts/install_dependencies.sh
        ./scripts/install_dependencies.sh
    
    - name: Executar testes unitários
      run: |
        echo "Configurando PYTHONPATH..."
        export PYTHONPATH="${PYTHONPATH}:$(pwd)"
        
        echo "Testando imports principais..."
        python -c "import war; print('war module OK')"
        python -c "from war.card import Card; print('Card OK')"
        python -c "from war.player import Player; print('Player OK')"
        python -c "from war.game import Game; print('Game OK')"
        python -c "from war.territory import Territory; print('Territory OK')"
        
        echo "Executando testes unitários..."
        python -m unittest discover tests/ --verbose --start-directory=. --pattern="test*.py" 2>&1 | tee test_report.txt
        
        echo "Testes concluídos!"
    
    - name: Upload do relatório de testes
      uses: actions/upload-artifact@v4
      with:
        name: test-report
        path: test_report.txt
        retention-days: 30

  # Job 2: Build/Empacotamento (executa em paralelo com testes)
  build:
    name: "Build e Empacotamento"
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
    
    - name: Configurar Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Instalar ferramentas de build via script
      run: |
        chmod +x ./scripts/install_build_tools.sh
        ./scripts/install_build_tools.sh
    
    - name: Criar pacote da aplicação
      run: |
        echo "Criando pacote da aplicação..."
        
        # Criar estrutura do pacote
        mkdir -p dist/war-game
        cp -r war/ dist/war-game/
        cp main.py dist/war-game/
        cp README.md dist/war-game/
        cp requirements.txt dist/war-game/
        cp -r data/ dist/war-game/ 2>/dev/null || true
        
        # Criar arquivo de instalação
        cat > dist/war-game/install.sh << 'EOF'
#!/bin/bash
echo "Instalando War Board Game..."
pip install pygame>=2.6.0
echo "Instalação concluída!"
echo "Para executar: python main.py"
EOF
        chmod +x dist/war-game/install.sh
        
        # Criar arquivo README para o pacote
        cat > dist/war-game/README_PACKAGE.md << 'EOF'
# War Board Game - Pacote Distribuível

## Instalação:
1. Execute: `./install.sh` (ou `pip install pygame>=2.6.0`)
2. Execute: `python main.py`

## Requisitos:
- Python 3.9+
- pygame 2.6.0+

## Estrutura:
- `main.py` - Arquivo principal do jogo
- `war/` - Módulos do jogo
- `data/` - Dados do jogo (mapas, missões)
EOF
        
        # Criar arquivo tar.gz
        cd dist && tar -czf war-game-v${{ github.run_number }}.tar.gz war-game/
        cd .. && ls -la dist/
        
        echo "Pacote criado com sucesso!"
    
    - name: Upload do pacote como artefato
      uses: actions/upload-artifact@v4
      with:
        name: war-game-package
        path: dist/war-game-v${{ github.run_number }}.tar.gz
        retention-days: 90

  # Job 3: Notificação por email (depende dos jobs anteriores)
  notification:
    name: "Envio de Notificação"
    runs-on: ubuntu-latest
    needs: [tests, build]
    if: always() # Executa mesmo se algum job falhar
    
    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
    
    - name: Configurar Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Executar notificação por email
      continue-on-error: true
      env:
        EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
        SMTP_SERVER: smtp.gmail.com
        SMTP_PORT: 587
        FROM_EMAIL: ${{ secrets.FROM_EMAIL }}
        NOTIFICATION_EMAIL: ${{ secrets.NOTIFICATION_EMAIL }}
      run: |
        if [ -n "$NOTIFICATION_EMAIL" ] && [ -n "$FROM_EMAIL" ] && [ -n "$EMAIL_PASSWORD" ]; then
          echo "Enviando notificação por email..."
          python scripts/send_notification.py \
            --to-email "$NOTIFICATION_EMAIL" \
            --pipeline-status "${{ needs.tests.result }}-success-${{ needs.build.result }}" \
            --run-number "${{ github.run_number }}" \
            --commit-sha "${{ github.sha }}" \
            --branch "${{ github.ref_name }}"
        else
          echo "Pipeline executado com sucesso!"
          echo "Status: Tests=${{ needs.tests.result }}, Build=${{ needs.build.result }}"
          echo "Configure os secrets (NOTIFICATION_EMAIL, FROM_EMAIL, EMAIL_PASSWORD) para ativar notificações por email"
          echo "Exemplo de configuração:"
          echo "- NOTIFICATION_EMAIL: seu-email@exemplo.com"
          echo "- FROM_EMAIL: remetente@gmail.com" 
          echo "- EMAIL_PASSWORD: senha-do-app-gmail"
        fi